{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridRowCountSelector, gridRowsLookupSelector, gridRowTreeSelector, gridRowIdsSelector, gridRowGroupingNameSelector } from './gridRowsSelector';\nimport { GridSignature, useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { gridSortedRowIdsSelector } from '../sorting/gridSortingSelector';\nimport { gridFilteredRowsLookupSelector } from '../filter/gridFilterSelector';\nimport { checkGridRowIdIsValid, getTreeNodeDescendants } from './gridRowsUtils';\n\nfunction getGridRowId(rowModel, getRowId, detailErrorMessage) {\n  const id = getRowId ? getRowId(rowModel) : rowModel.id;\n  checkGridRowIdIsValid(id, rowModel, detailErrorMessage);\n  return id;\n}\n\nconst convertRowsPropToState = _ref2 => {\n  let {\n    prevCache: prevState,\n    rows,\n    getRowId\n  } = _ref2;\n  let value;\n\n  if (rows) {\n    value = {\n      idRowsLookup: {},\n      idToIdLookup: {},\n      ids: []\n    };\n\n    for (let i = 0; i < rows.length; i += 1) {\n      const row = rows[i];\n      const id = getGridRowId(row, getRowId);\n      value.idRowsLookup[id] = row;\n      value.idToIdLookup[id] = id;\n      value.ids.push(id);\n    }\n  } else {\n    value = prevState.value;\n  }\n\n  return {\n    value,\n    rowsBeforePartialUpdates: rows != null ? rows : prevState.rowsBeforePartialUpdates\n  };\n};\n\nconst getRowsStateFromCache = (rowsCache, previousTree, apiRef, rowCountProp, loadingProp) => {\n  const {\n    value\n  } = rowsCache;\n  const rowCount = rowCountProp != null ? rowCountProp : 0;\n  const groupingResponse = apiRef.current.unstable_applyStrategyProcessor('rowTreeCreation', _extends({}, value, {\n    previousTree\n  }));\n  const dataTopLevelRowCount = groupingResponse.treeDepth === 1 ? groupingResponse.ids.length : Object.values(groupingResponse.tree).filter(node => node.parent == null).length;\n  return _extends({}, groupingResponse, {\n    loading: loadingProp,\n    totalRowCount: Math.max(rowCount, groupingResponse.ids.length),\n    totalTopLevelRowCount: Math.max(rowCount, dataTopLevelRowCount)\n  });\n};\n\nexport const rowsStateInitializer = (state, props, apiRef) => {\n  apiRef.current.unstable_caches.rows = convertRowsPropToState({\n    rows: props.rows,\n    getRowId: props.getRowId,\n    prevCache: {\n      value: {\n        idRowsLookup: {},\n        idToIdLookup: {},\n        ids: []\n      },\n      rowsBeforePartialUpdates: []\n    }\n  });\n  return _extends({}, state, {\n    rows: getRowsStateFromCache(apiRef.current.unstable_caches.rows, null, apiRef, props.rowCount, props.loading)\n  });\n};\nexport const useGridRows = (apiRef, props) => {\n  if (process.env.NODE_ENV !== 'production') {\n    // Freeze rows for immutability\n    Object.freeze(props.rows);\n  }\n\n  const logger = useGridLogger(apiRef, 'useGridRows');\n  const currentPage = useGridVisibleRows(apiRef, props);\n  const lastUpdateMs = React.useRef(Date.now());\n  const timeout = React.useRef(null);\n  const getRow = React.useCallback(id => {\n    var _ref;\n\n    return (_ref = gridRowsLookupSelector(apiRef)[id]) != null ? _ref : null;\n  }, [apiRef]);\n  const lookup = React.useMemo(() => currentPage.rows.reduce((acc, _ref3, index) => {\n    let {\n      id\n    } = _ref3;\n    acc[id] = index;\n    return acc;\n  }, {}), [currentPage.rows]);\n  const throttledRowsChange = React.useCallback((newCache, throttle) => {\n    const run = () => {\n      timeout.current = null;\n      lastUpdateMs.current = Date.now();\n      apiRef.current.setState(state => _extends({}, state, {\n        rows: getRowsStateFromCache(apiRef.current.unstable_caches.rows, gridRowTreeSelector(apiRef), apiRef, props.rowCount, props.loading)\n      }));\n      apiRef.current.publishEvent('rowsSet');\n      apiRef.current.forceUpdate();\n    };\n\n    if (timeout.current) {\n      clearTimeout(timeout.current);\n      timeout.current = null;\n    }\n\n    apiRef.current.unstable_caches.rows = newCache;\n\n    if (!throttle) {\n      run();\n      return;\n    }\n\n    const throttleRemainingTimeMs = props.throttleRowsMs - (Date.now() - lastUpdateMs.current);\n\n    if (throttleRemainingTimeMs > 0) {\n      timeout.current = setTimeout(run, throttleRemainingTimeMs);\n      return;\n    }\n\n    run();\n  }, [props.throttleRowsMs, props.rowCount, props.loading, apiRef]);\n  /**\n   * API METHODS\n   */\n\n  const setRows = React.useCallback(rows => {\n    logger.debug(`Updating all rows, new length ${rows.length}`);\n    throttledRowsChange(convertRowsPropToState({\n      rows,\n      prevCache: apiRef.current.unstable_caches.rows,\n      getRowId: props.getRowId\n    }), true);\n  }, [apiRef, logger, props.getRowId, throttledRowsChange]);\n  const updateRows = React.useCallback(updates => {\n    if (props.signature === GridSignature.DataGrid && updates.length > 1) {\n      // TODO: Add test with direct call to `apiRef.current.updateRows` in DataGrid after enabling the `apiRef` on the free plan.\n      throw new Error([\"MUI: You can't update several rows at once in `apiRef.current.updateRows` on the DataGrid.\", 'You need to upgrade to the DataGridPro component to unlock this feature.'].join('\\n'));\n    } // we remove duplicate updates. A server can batch updates, and send several updates for the same row in one fn call.\n\n\n    const uniqUpdates = new Map();\n    updates.forEach(update => {\n      const id = getGridRowId(update, props.getRowId, 'A row was provided without id when calling updateRows():');\n\n      if (uniqUpdates.has(id)) {\n        uniqUpdates.set(id, _extends({}, uniqUpdates.get(id), update));\n      } else {\n        uniqUpdates.set(id, update);\n      }\n    });\n    const deletedRowIds = [];\n    const newStateValue = {\n      idRowsLookup: _extends({}, apiRef.current.unstable_caches.rows.value.idRowsLookup),\n      idToIdLookup: _extends({}, apiRef.current.unstable_caches.rows.value.idToIdLookup),\n      ids: [...apiRef.current.unstable_caches.rows.value.ids]\n    };\n    uniqUpdates.forEach((partialRow, id) => {\n      // eslint-disable-next-line no-underscore-dangle\n      if (partialRow._action === 'delete') {\n        delete newStateValue.idRowsLookup[id];\n        delete newStateValue.idToIdLookup[id];\n        deletedRowIds.push(id);\n        return;\n      }\n\n      const oldRow = apiRef.current.getRow(id);\n\n      if (!oldRow) {\n        newStateValue.idRowsLookup[id] = partialRow;\n        newStateValue.idToIdLookup[id] = id;\n        newStateValue.ids.push(id);\n        return;\n      }\n\n      newStateValue.idRowsLookup[id] = _extends({}, apiRef.current.getRow(id), partialRow);\n    });\n\n    if (deletedRowIds.length > 0) {\n      newStateValue.ids = newStateValue.ids.filter(id => !deletedRowIds.includes(id));\n    }\n\n    const state = _extends({}, apiRef.current.unstable_caches.rows, {\n      value: newStateValue\n    });\n\n    throttledRowsChange(state, true);\n  }, [props.signature, props.getRowId, throttledRowsChange, apiRef]);\n  const getRowModels = React.useCallback(() => {\n    const allRows = gridRowIdsSelector(apiRef);\n    const idRowsLookup = gridRowsLookupSelector(apiRef);\n    return new Map(allRows.map(id => [id, idRowsLookup[id]]));\n  }, [apiRef]);\n  const getRowsCount = React.useCallback(() => gridRowCountSelector(apiRef), [apiRef]);\n  const getAllRowIds = React.useCallback(() => gridRowIdsSelector(apiRef), [apiRef]);\n  const getRowIndexRelativeToVisibleRows = React.useCallback(id => lookup[id], [lookup]);\n  const setRowChildrenExpansion = React.useCallback((id, isExpanded) => {\n    const currentNode = apiRef.current.getRowNode(id);\n\n    if (!currentNode) {\n      throw new Error(`MUI: No row with id #${id} found`);\n    }\n\n    const newNode = _extends({}, currentNode, {\n      childrenExpanded: isExpanded\n    });\n\n    apiRef.current.setState(state => {\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, {\n          tree: _extends({}, state.rows.tree, {\n            [id]: newNode\n          })\n        })\n      });\n    });\n    apiRef.current.forceUpdate();\n    apiRef.current.publishEvent('rowExpansionChange', newNode);\n  }, [apiRef]);\n  const getRowNode = React.useCallback(id => {\n    var _gridRowTreeSelector$;\n\n    return (_gridRowTreeSelector$ = gridRowTreeSelector(apiRef)[id]) != null ? _gridRowTreeSelector$ : null;\n  }, [apiRef]);\n  const getRowGroupChildren = React.useCallback(_ref4 => {\n    let {\n      skipAutoGeneratedRows = true,\n      groupId,\n      applySorting,\n      applyFiltering\n    } = _ref4;\n    const tree = gridRowTreeSelector(apiRef);\n    let children;\n\n    if (applySorting) {\n      const groupNode = tree[groupId];\n\n      if (!groupNode) {\n        return [];\n      }\n\n      const sortedRowIds = gridSortedRowIdsSelector(apiRef);\n      children = [];\n      const startIndex = sortedRowIds.findIndex(id => id === groupId) + 1;\n\n      for (let index = startIndex; index < sortedRowIds.length && tree[sortedRowIds[index]].depth > groupNode.depth; index += 1) {\n        const id = sortedRowIds[index];\n        const node = tree[id];\n\n        if (!skipAutoGeneratedRows || !node.isAutoGenerated) {\n          children.push(id);\n        }\n      }\n    } else {\n      children = getTreeNodeDescendants(tree, groupId, skipAutoGeneratedRows);\n    }\n\n    if (applyFiltering) {\n      const filteredRowsLookup = gridFilteredRowsLookupSelector(apiRef);\n      children = children.filter(childId => filteredRowsLookup[childId] !== false);\n    }\n\n    return children;\n  }, [apiRef]);\n  const setRowIndex = React.useCallback((rowId, targetIndex) => {\n    const allRows = gridRowIdsSelector(apiRef);\n    const oldIndex = allRows.findIndex(row => row === rowId);\n\n    if (oldIndex === -1 || oldIndex === targetIndex) {\n      return;\n    }\n\n    logger.debug(`Moving row ${rowId} to index ${targetIndex}`);\n    const updatedRows = [...allRows];\n    updatedRows.splice(targetIndex, 0, updatedRows.splice(oldIndex, 1)[0]);\n    apiRef.current.setState(state => _extends({}, state, {\n      rows: _extends({}, state.rows, {\n        ids: updatedRows\n      })\n    }));\n    apiRef.current.applySorting();\n  }, [apiRef, logger]);\n  const rowApi = {\n    getRow,\n    getRowModels,\n    getRowsCount,\n    getAllRowIds,\n    setRows,\n    setRowIndex,\n    updateRows,\n    setRowChildrenExpansion,\n    getRowNode,\n    getRowIndexRelativeToVisibleRows,\n    getRowGroupChildren\n  };\n  /**\n   * EVENTS\n   */\n\n  const groupRows = React.useCallback(() => {\n    logger.info(`Row grouping pre-processing have changed, regenerating the row tree`);\n    let rows;\n\n    if (apiRef.current.unstable_caches.rows.rowsBeforePartialUpdates === props.rows) {\n      // The `props.rows` has not changed since the last row grouping\n      // We can keep the potential updates stored in `inputRowsAfterUpdates` on the new grouping\n      rows = undefined;\n    } else {\n      // The `props.rows` has changed since the last row grouping\n      // We must use the new `props.rows` on the new grouping\n      // This occurs because this event is triggered before the `useEffect` on the rows when both the grouping pre-processing and the rows changes on the same render\n      rows = props.rows;\n    }\n\n    throttledRowsChange(convertRowsPropToState({\n      rows,\n      getRowId: props.getRowId,\n      prevCache: apiRef.current.unstable_caches.rows\n    }), false);\n  }, [logger, apiRef, props.rows, props.getRowId, throttledRowsChange]);\n  const handleStrategyProcessorChange = React.useCallback(methodName => {\n    if (methodName === 'rowTreeCreation') {\n      groupRows();\n    }\n  }, [groupRows]);\n  const handleStrategyActivityChange = React.useCallback(() => {\n    // `rowTreeCreation` is the only processor ran when `strategyAvailabilityChange` is fired.\n    // All the other processors listen to `rowsSet` which will be published by the `groupRows` method below.\n    if (apiRef.current.unstable_getActiveStrategy('rowTree') !== gridRowGroupingNameSelector(apiRef)) {\n      groupRows();\n    }\n  }, [apiRef, groupRows]);\n  useGridApiEventHandler(apiRef, 'activeStrategyProcessorChange', handleStrategyProcessorChange);\n  useGridApiEventHandler(apiRef, 'strategyAvailabilityChange', handleStrategyActivityChange);\n  useGridApiMethod(apiRef, rowApi, 'GridRowApi');\n  /**\n   * EFFECTS\n   */\n\n  React.useEffect(() => {\n    return () => {\n      if (timeout.current !== null) {\n        clearTimeout(timeout.current);\n      }\n    };\n  }, []); // The effect do not track any value defined synchronously during the 1st render by hooks called after `useGridRows`\n  // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one\n\n  const isFirstRender = React.useRef(true);\n  React.useEffect(() => {\n    if (isFirstRender.current) {\n      isFirstRender.current = false;\n      return;\n    } // The new rows have already been applied (most likely in the `'rowGroupsPreProcessingChange'` listener)\n\n\n    if (apiRef.current.unstable_caches.rows.rowsBeforePartialUpdates === props.rows) {\n      return;\n    }\n\n    logger.debug(`Updating all rows, new length ${props.rows.length}`);\n    throttledRowsChange(convertRowsPropToState({\n      rows: props.rows,\n      getRowId: props.getRowId,\n      prevCache: apiRef.current.unstable_caches.rows\n    }), false);\n  }, [props.rows, props.rowCount, props.getRowId, logger, throttledRowsChange, apiRef]);\n};","map":{"version":3,"names":["_extends","React","useGridApiMethod","useGridLogger","gridRowCountSelector","gridRowsLookupSelector","gridRowTreeSelector","gridRowIdsSelector","gridRowGroupingNameSelector","GridSignature","useGridApiEventHandler","useGridVisibleRows","gridSortedRowIdsSelector","gridFilteredRowsLookupSelector","checkGridRowIdIsValid","getTreeNodeDescendants","getGridRowId","rowModel","getRowId","detailErrorMessage","id","convertRowsPropToState","prevCache","prevState","rows","value","idRowsLookup","idToIdLookup","ids","i","length","row","push","rowsBeforePartialUpdates","getRowsStateFromCache","rowsCache","previousTree","apiRef","rowCountProp","loadingProp","rowCount","groupingResponse","current","unstable_applyStrategyProcessor","dataTopLevelRowCount","treeDepth","Object","values","tree","filter","node","parent","loading","totalRowCount","Math","max","totalTopLevelRowCount","rowsStateInitializer","state","props","unstable_caches","useGridRows","process","env","NODE_ENV","freeze","logger","currentPage","lastUpdateMs","useRef","Date","now","timeout","getRow","useCallback","_ref","lookup","useMemo","reduce","acc","index","throttledRowsChange","newCache","throttle","run","setState","publishEvent","forceUpdate","clearTimeout","throttleRemainingTimeMs","throttleRowsMs","setTimeout","setRows","debug","updateRows","updates","signature","DataGrid","Error","join","uniqUpdates","Map","forEach","update","has","set","get","deletedRowIds","newStateValue","partialRow","_action","oldRow","includes","getRowModels","allRows","map","getRowsCount","getAllRowIds","getRowIndexRelativeToVisibleRows","setRowChildrenExpansion","isExpanded","currentNode","getRowNode","newNode","childrenExpanded","_gridRowTreeSelector$","getRowGroupChildren","skipAutoGeneratedRows","groupId","applySorting","applyFiltering","children","groupNode","sortedRowIds","startIndex","findIndex","depth","isAutoGenerated","filteredRowsLookup","childId","setRowIndex","rowId","targetIndex","oldIndex","updatedRows","splice","rowApi","groupRows","info","undefined","handleStrategyProcessorChange","methodName","handleStrategyActivityChange","unstable_getActiveStrategy","useEffect","isFirstRender"],"sources":["/Users/deanfoster/Personal Budget/view/client/node_modules/@mui/x-data-grid/hooks/features/rows/useGridRows.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridRowCountSelector, gridRowsLookupSelector, gridRowTreeSelector, gridRowIdsSelector, gridRowGroupingNameSelector } from './gridRowsSelector';\nimport { GridSignature, useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { gridSortedRowIdsSelector } from '../sorting/gridSortingSelector';\nimport { gridFilteredRowsLookupSelector } from '../filter/gridFilterSelector';\nimport { checkGridRowIdIsValid, getTreeNodeDescendants } from './gridRowsUtils';\n\nfunction getGridRowId(rowModel, getRowId, detailErrorMessage) {\n  const id = getRowId ? getRowId(rowModel) : rowModel.id;\n  checkGridRowIdIsValid(id, rowModel, detailErrorMessage);\n  return id;\n}\n\nconst convertRowsPropToState = ({\n  prevCache: prevState,\n  rows,\n  getRowId\n}) => {\n  let value;\n\n  if (rows) {\n    value = {\n      idRowsLookup: {},\n      idToIdLookup: {},\n      ids: []\n    };\n\n    for (let i = 0; i < rows.length; i += 1) {\n      const row = rows[i];\n      const id = getGridRowId(row, getRowId);\n      value.idRowsLookup[id] = row;\n      value.idToIdLookup[id] = id;\n      value.ids.push(id);\n    }\n  } else {\n    value = prevState.value;\n  }\n\n  return {\n    value,\n    rowsBeforePartialUpdates: rows != null ? rows : prevState.rowsBeforePartialUpdates\n  };\n};\n\nconst getRowsStateFromCache = (rowsCache, previousTree, apiRef, rowCountProp, loadingProp) => {\n  const {\n    value\n  } = rowsCache;\n  const rowCount = rowCountProp != null ? rowCountProp : 0;\n  const groupingResponse = apiRef.current.unstable_applyStrategyProcessor('rowTreeCreation', _extends({}, value, {\n    previousTree\n  }));\n  const dataTopLevelRowCount = groupingResponse.treeDepth === 1 ? groupingResponse.ids.length : Object.values(groupingResponse.tree).filter(node => node.parent == null).length;\n  return _extends({}, groupingResponse, {\n    loading: loadingProp,\n    totalRowCount: Math.max(rowCount, groupingResponse.ids.length),\n    totalTopLevelRowCount: Math.max(rowCount, dataTopLevelRowCount)\n  });\n};\n\nexport const rowsStateInitializer = (state, props, apiRef) => {\n  apiRef.current.unstable_caches.rows = convertRowsPropToState({\n    rows: props.rows,\n    getRowId: props.getRowId,\n    prevCache: {\n      value: {\n        idRowsLookup: {},\n        idToIdLookup: {},\n        ids: []\n      },\n      rowsBeforePartialUpdates: []\n    }\n  });\n  return _extends({}, state, {\n    rows: getRowsStateFromCache(apiRef.current.unstable_caches.rows, null, apiRef, props.rowCount, props.loading)\n  });\n};\nexport const useGridRows = (apiRef, props) => {\n  if (process.env.NODE_ENV !== 'production') {\n    // Freeze rows for immutability\n    Object.freeze(props.rows);\n  }\n\n  const logger = useGridLogger(apiRef, 'useGridRows');\n  const currentPage = useGridVisibleRows(apiRef, props);\n  const lastUpdateMs = React.useRef(Date.now());\n  const timeout = React.useRef(null);\n  const getRow = React.useCallback(id => {\n    var _ref;\n\n    return (_ref = gridRowsLookupSelector(apiRef)[id]) != null ? _ref : null;\n  }, [apiRef]);\n  const lookup = React.useMemo(() => currentPage.rows.reduce((acc, {\n    id\n  }, index) => {\n    acc[id] = index;\n    return acc;\n  }, {}), [currentPage.rows]);\n  const throttledRowsChange = React.useCallback((newCache, throttle) => {\n    const run = () => {\n      timeout.current = null;\n      lastUpdateMs.current = Date.now();\n      apiRef.current.setState(state => _extends({}, state, {\n        rows: getRowsStateFromCache(apiRef.current.unstable_caches.rows, gridRowTreeSelector(apiRef), apiRef, props.rowCount, props.loading)\n      }));\n      apiRef.current.publishEvent('rowsSet');\n      apiRef.current.forceUpdate();\n    };\n\n    if (timeout.current) {\n      clearTimeout(timeout.current);\n      timeout.current = null;\n    }\n\n    apiRef.current.unstable_caches.rows = newCache;\n\n    if (!throttle) {\n      run();\n      return;\n    }\n\n    const throttleRemainingTimeMs = props.throttleRowsMs - (Date.now() - lastUpdateMs.current);\n\n    if (throttleRemainingTimeMs > 0) {\n      timeout.current = setTimeout(run, throttleRemainingTimeMs);\n      return;\n    }\n\n    run();\n  }, [props.throttleRowsMs, props.rowCount, props.loading, apiRef]);\n  /**\n   * API METHODS\n   */\n\n  const setRows = React.useCallback(rows => {\n    logger.debug(`Updating all rows, new length ${rows.length}`);\n    throttledRowsChange(convertRowsPropToState({\n      rows,\n      prevCache: apiRef.current.unstable_caches.rows,\n      getRowId: props.getRowId\n    }), true);\n  }, [apiRef, logger, props.getRowId, throttledRowsChange]);\n  const updateRows = React.useCallback(updates => {\n    if (props.signature === GridSignature.DataGrid && updates.length > 1) {\n      // TODO: Add test with direct call to `apiRef.current.updateRows` in DataGrid after enabling the `apiRef` on the free plan.\n      throw new Error([\"MUI: You can't update several rows at once in `apiRef.current.updateRows` on the DataGrid.\", 'You need to upgrade to the DataGridPro component to unlock this feature.'].join('\\n'));\n    } // we remove duplicate updates. A server can batch updates, and send several updates for the same row in one fn call.\n\n\n    const uniqUpdates = new Map();\n    updates.forEach(update => {\n      const id = getGridRowId(update, props.getRowId, 'A row was provided without id when calling updateRows():');\n\n      if (uniqUpdates.has(id)) {\n        uniqUpdates.set(id, _extends({}, uniqUpdates.get(id), update));\n      } else {\n        uniqUpdates.set(id, update);\n      }\n    });\n    const deletedRowIds = [];\n    const newStateValue = {\n      idRowsLookup: _extends({}, apiRef.current.unstable_caches.rows.value.idRowsLookup),\n      idToIdLookup: _extends({}, apiRef.current.unstable_caches.rows.value.idToIdLookup),\n      ids: [...apiRef.current.unstable_caches.rows.value.ids]\n    };\n    uniqUpdates.forEach((partialRow, id) => {\n      // eslint-disable-next-line no-underscore-dangle\n      if (partialRow._action === 'delete') {\n        delete newStateValue.idRowsLookup[id];\n        delete newStateValue.idToIdLookup[id];\n        deletedRowIds.push(id);\n        return;\n      }\n\n      const oldRow = apiRef.current.getRow(id);\n\n      if (!oldRow) {\n        newStateValue.idRowsLookup[id] = partialRow;\n        newStateValue.idToIdLookup[id] = id;\n        newStateValue.ids.push(id);\n        return;\n      }\n\n      newStateValue.idRowsLookup[id] = _extends({}, apiRef.current.getRow(id), partialRow);\n    });\n\n    if (deletedRowIds.length > 0) {\n      newStateValue.ids = newStateValue.ids.filter(id => !deletedRowIds.includes(id));\n    }\n\n    const state = _extends({}, apiRef.current.unstable_caches.rows, {\n      value: newStateValue\n    });\n\n    throttledRowsChange(state, true);\n  }, [props.signature, props.getRowId, throttledRowsChange, apiRef]);\n  const getRowModels = React.useCallback(() => {\n    const allRows = gridRowIdsSelector(apiRef);\n    const idRowsLookup = gridRowsLookupSelector(apiRef);\n    return new Map(allRows.map(id => [id, idRowsLookup[id]]));\n  }, [apiRef]);\n  const getRowsCount = React.useCallback(() => gridRowCountSelector(apiRef), [apiRef]);\n  const getAllRowIds = React.useCallback(() => gridRowIdsSelector(apiRef), [apiRef]);\n  const getRowIndexRelativeToVisibleRows = React.useCallback(id => lookup[id], [lookup]);\n  const setRowChildrenExpansion = React.useCallback((id, isExpanded) => {\n    const currentNode = apiRef.current.getRowNode(id);\n\n    if (!currentNode) {\n      throw new Error(`MUI: No row with id #${id} found`);\n    }\n\n    const newNode = _extends({}, currentNode, {\n      childrenExpanded: isExpanded\n    });\n\n    apiRef.current.setState(state => {\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, {\n          tree: _extends({}, state.rows.tree, {\n            [id]: newNode\n          })\n        })\n      });\n    });\n    apiRef.current.forceUpdate();\n    apiRef.current.publishEvent('rowExpansionChange', newNode);\n  }, [apiRef]);\n  const getRowNode = React.useCallback(id => {\n    var _gridRowTreeSelector$;\n\n    return (_gridRowTreeSelector$ = gridRowTreeSelector(apiRef)[id]) != null ? _gridRowTreeSelector$ : null;\n  }, [apiRef]);\n  const getRowGroupChildren = React.useCallback(({\n    skipAutoGeneratedRows = true,\n    groupId,\n    applySorting,\n    applyFiltering\n  }) => {\n    const tree = gridRowTreeSelector(apiRef);\n    let children;\n\n    if (applySorting) {\n      const groupNode = tree[groupId];\n\n      if (!groupNode) {\n        return [];\n      }\n\n      const sortedRowIds = gridSortedRowIdsSelector(apiRef);\n      children = [];\n      const startIndex = sortedRowIds.findIndex(id => id === groupId) + 1;\n\n      for (let index = startIndex; index < sortedRowIds.length && tree[sortedRowIds[index]].depth > groupNode.depth; index += 1) {\n        const id = sortedRowIds[index];\n        const node = tree[id];\n\n        if (!skipAutoGeneratedRows || !node.isAutoGenerated) {\n          children.push(id);\n        }\n      }\n    } else {\n      children = getTreeNodeDescendants(tree, groupId, skipAutoGeneratedRows);\n    }\n\n    if (applyFiltering) {\n      const filteredRowsLookup = gridFilteredRowsLookupSelector(apiRef);\n      children = children.filter(childId => filteredRowsLookup[childId] !== false);\n    }\n\n    return children;\n  }, [apiRef]);\n  const setRowIndex = React.useCallback((rowId, targetIndex) => {\n    const allRows = gridRowIdsSelector(apiRef);\n    const oldIndex = allRows.findIndex(row => row === rowId);\n\n    if (oldIndex === -1 || oldIndex === targetIndex) {\n      return;\n    }\n\n    logger.debug(`Moving row ${rowId} to index ${targetIndex}`);\n    const updatedRows = [...allRows];\n    updatedRows.splice(targetIndex, 0, updatedRows.splice(oldIndex, 1)[0]);\n    apiRef.current.setState(state => _extends({}, state, {\n      rows: _extends({}, state.rows, {\n        ids: updatedRows\n      })\n    }));\n    apiRef.current.applySorting();\n  }, [apiRef, logger]);\n  const rowApi = {\n    getRow,\n    getRowModels,\n    getRowsCount,\n    getAllRowIds,\n    setRows,\n    setRowIndex,\n    updateRows,\n    setRowChildrenExpansion,\n    getRowNode,\n    getRowIndexRelativeToVisibleRows,\n    getRowGroupChildren\n  };\n  /**\n   * EVENTS\n   */\n\n  const groupRows = React.useCallback(() => {\n    logger.info(`Row grouping pre-processing have changed, regenerating the row tree`);\n    let rows;\n\n    if (apiRef.current.unstable_caches.rows.rowsBeforePartialUpdates === props.rows) {\n      // The `props.rows` has not changed since the last row grouping\n      // We can keep the potential updates stored in `inputRowsAfterUpdates` on the new grouping\n      rows = undefined;\n    } else {\n      // The `props.rows` has changed since the last row grouping\n      // We must use the new `props.rows` on the new grouping\n      // This occurs because this event is triggered before the `useEffect` on the rows when both the grouping pre-processing and the rows changes on the same render\n      rows = props.rows;\n    }\n\n    throttledRowsChange(convertRowsPropToState({\n      rows,\n      getRowId: props.getRowId,\n      prevCache: apiRef.current.unstable_caches.rows\n    }), false);\n  }, [logger, apiRef, props.rows, props.getRowId, throttledRowsChange]);\n  const handleStrategyProcessorChange = React.useCallback(methodName => {\n    if (methodName === 'rowTreeCreation') {\n      groupRows();\n    }\n  }, [groupRows]);\n  const handleStrategyActivityChange = React.useCallback(() => {\n    // `rowTreeCreation` is the only processor ran when `strategyAvailabilityChange` is fired.\n    // All the other processors listen to `rowsSet` which will be published by the `groupRows` method below.\n    if (apiRef.current.unstable_getActiveStrategy('rowTree') !== gridRowGroupingNameSelector(apiRef)) {\n      groupRows();\n    }\n  }, [apiRef, groupRows]);\n  useGridApiEventHandler(apiRef, 'activeStrategyProcessorChange', handleStrategyProcessorChange);\n  useGridApiEventHandler(apiRef, 'strategyAvailabilityChange', handleStrategyActivityChange);\n  useGridApiMethod(apiRef, rowApi, 'GridRowApi');\n  /**\n   * EFFECTS\n   */\n\n  React.useEffect(() => {\n    return () => {\n      if (timeout.current !== null) {\n        clearTimeout(timeout.current);\n      }\n    };\n  }, []); // The effect do not track any value defined synchronously during the 1st render by hooks called after `useGridRows`\n  // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one\n\n  const isFirstRender = React.useRef(true);\n  React.useEffect(() => {\n    if (isFirstRender.current) {\n      isFirstRender.current = false;\n      return;\n    } // The new rows have already been applied (most likely in the `'rowGroupsPreProcessingChange'` listener)\n\n\n    if (apiRef.current.unstable_caches.rows.rowsBeforePartialUpdates === props.rows) {\n      return;\n    }\n\n    logger.debug(`Updating all rows, new length ${props.rows.length}`);\n    throttledRowsChange(convertRowsPropToState({\n      rows: props.rows,\n      getRowId: props.getRowId,\n      prevCache: apiRef.current.unstable_caches.rows\n    }), false);\n  }, [props.rows, props.rowCount, props.getRowId, logger, throttledRowsChange, apiRef]);\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}